//await page.waitForLoadState("networkidle") it can nicely wait for network provided by utility playwright

also you can make the multiple browser context and run them at once
//command to run test in trace view along - npx playwright test --ui
//npx playwright test multiContext.spec.js --workers 3
runt the test in debug mode:npx playwright test tests/e2e_shopping.spec.js --debug

=== Playwright Agents Overview (September 12, 2025) ===

=== Playwright MCP Accessibility Snapshots (September 12, 2025) ===
=== codegen - npx p;aywright codegen https://qa-contractorportal.birlaopus.com/

Playwright MCP uses accessibility snapshots as a key feature for web automation. Here's how it works:

1. Snapshot Creation:
   - Instead of using pixel-based visual analysis
   - Creates a structured representation of the page through the accessibility tree
   - Provides clean, structured data that LLMs can easily understand and process

2. Key Benefits:
   - Fast & Lightweight: No need for heavy vision models or image processing
   - Reliable: Uses semantic structure rather than visual appearance
   - Deterministic: Based on page structure, not visual positions
   - LLM-Friendly: Provides data in a format that AI can easily parse

3. How It Works:
   - browser_snapshot tool captures the page state
   - Represents elements with their roles, names, and relationships
   - Creates a hierarchical structure similar to what screen readers use
   - Includes interactive properties (clickable, editable, etc.)

4. Advantages Over Traditional Automation:
   - More stable than pixel-based or coordinate-based automation
   - Better handling of dynamic content
   - More accessible and semantic approach to web interaction
   - Closer to how humans understand web pages

5. Practical Usage:
   - AI can understand page structure and content
   - Can locate elements by their semantic meaning
   - Makes decisions based on accessibility tree rather than visual layout
   - More robust automation across different screen sizes and layouts

This approach makes web automation more reliable and maintainable while being more efficient than traditional visual-based approaches.

Playwright Agents is a powerful automation solution that combines AI with browser automation. Here's a comprehensive overview:

1. What is Playwright MCP (Model Context Protocol)?
- It's a communication standard that allows AI agents to control web browsers
- Built on top of Playwright's core technology
- Uses accessibility snapshots instead of pixel-based interaction
- Provides a structured, reliable way for AI to interact with web pages

2. Key Advantages:
- Fast & Lightweight: No need for heavy vision models
- Reliable: Uses element roles and names instead of positions
- LLM-Friendly: Provides clean, structured data
- Natural Language Control: Accept plain English commands

3. Main Use Cases:

For Development:
- Automated test generation
- Website exploration and test case discovery
- Interactive debugging assistance

For Automation:
- Form filling and data entry
- Multi-step process automation
- Web scraping and data extraction
- Dashboard monitoring

4. How It Works:
- MCP Client: Your interface (e.g., VS Code with GitHub Copilot)
- MCP Server: The "hands" that execute commands
- AI Agent: Translates natural language to browser actions

5. Getting Started:
- Install via VS Code extension
- Uses @playwright/mcp package
- Simple JSON configuration
- Immediate browser control through natural language

Example Usage Scenarios:
- "Fill out this contact form with our company details"
- "Check GitHub issues for critical bugs"
- "Generate tests for shopping cart checkout"
- "Extract data from multiple web pages"


DO EFFECTICE SELECTOR RETRIES

This technology bridges the gap between natural language instructions and automated browser interactions, making web automation more accessible and maintainable.
-------------------------------------------------------------------------------------------------------------------------------------
Basic Multiple Contexts Example: -  multiContext.spec.js

The first test shows how to create two separate browser contexts (adminContext and userContext)
Each context gets its own page object
The contexts operate independently, simulating different user sessions
Perfect for testing multi-user scenarios
Contexts with Different Storage States:

The second test demonstrates how to create contexts with different storage states
Each context can have its own:
Cookies
localStorage
sessionStorage
Other browser storage mechanisms
Key Benefits of Multiple Contexts:

Isolation: Each context is completely isolated from others
Independent Sessions: Perfect for testing multi-user scenarios
Different Configurations: Each context can have different:
Storage states
Permissions
Geolocation
Color schemes
Viewport sizes
To run this specific test, you can use:



---------------------
to view trace use trace.playwright.dev drag the trace.zip here

//     # View a trace file
// npx playwright show-trace trace.zip

// # View trace from directory
// npx playwright show-trace trace/

e.g
npx playwright show-trace test-results\PainterManage-Painter-Mana-6dc4c-reate-a-new-Painter-profile-chrome/trace.zip          

# Give failing tests 3 retry attempts
npx playwright test --retries=3

Add the following to the top of your JavaScript file to get type-checking in VS Code or WebStorm.
// @ts-check
// ...

=========Auto-retrying assertions=========

Assertion	Description
await expect(locator).toBeAttached()	Element is attached
await expect(locator).toBeChecked()	Checkbox is checked
await expect(locator).toBeDisabled()	Element is disabled
await expect(locator).toBeEditable()	Element is editable
await expect(locator).toBeEmpty()	Container is empty
await expect(locator).toBeEnabled()	Element is enabled
await expect(locator).toBeFocused()	Element is focused
await expect(locator).toBeHidden()	Element is not visible
await expect(locator).toBeInViewport()	Element intersects viewport
await expect(locator).toBeVisible()	Element is visible
await expect(locator).toContainText()	Element contains text
await expect(locator).toContainClass()	Element has specified CSS classes
await expect(locator).toHaveAccessibleDescription()	Element has a matching accessible description
await expect(locator).toHaveAccessibleName()	Element has a matching accessible name
await expect(locator).toHaveAttribute()	Element has a DOM attribute
await expect(locator).toHaveClass()	Element has specified CSS class property
await expect(locator).toHaveCount()	List has exact number of children
await expect(locator).toHaveCSS()	Element has CSS property
await expect(locator).toHaveId()	Element has an ID
await expect(locator).toHaveJSProperty()	Element has a JavaScript property
await expect(locator).toHaveRole()	Element has a specific ARIA role
await expect(locator).toHaveScreenshot()	Element has a screenshot
await expect(locator).toHaveText()	Element matches text
await expect(locator).toHaveValue()	Input has a value
await expect(locator).toHaveValues()	Select has options selected
await expect(locator).toMatchAriaSnapshot()	Element matches the Aria snapshot
await expect(page).toHaveScreenshot()	Page has a screenshot
await expect(page).toHaveTitle()	Page has a title
await expect(page).toHaveURL()	Page has a URL
await expect(response).toBeOK()	Response has an OK status

=========Non-retrying assertions=========
Assertion	Description
expect(value).toBe()	Value is the same
expect(value).toBeCloseTo()	Number is approximately equal
expect(value).toBeDefined()	Value is not undefined
expect(value).toBeFalsy()	Value is falsy, e.g. false, 0, null, etc.
expect(value).toBeGreaterThan()	Number is more than
expect(value).toBeGreaterThanOrEqual()	Number is more than or equal
expect(value).toBeInstanceOf()	Object is an instance of a class
expect(value).toBeLessThan()	Number is less than
expect(value).toBeLessThanOrEqual()	Number is less than or equal
expect(value).toBeNaN()	Value is NaN
expect(value).toBeNull()	Value is null
expect(value).toBeTruthy()	Value is truthy, i.e. not false, 0, null, etc.
expect(value).toBeUndefined()	Value is undefined
expect(value).toContain()	String contains a substring
expect(value).toContain()	Array or set contains an element
expect(value).toContainEqual()	Array or set contains a similar element
expect(value).toEqual()	Value is similar - deep equality and pattern matching
expect(value).toHaveLength()	Array or string has length
expect(value).toHaveProperty()	Object has a property
expect(value).toMatch()	String matches a regular expression
expect(value).toMatchObject()	Object contains specified properties
expect(value).toStrictEqual()	Value is similar, including property types
expect(value).toThrow()	Function throws an error
expect(value).any()	Matches any instance of a class/primitive
expect(value).anything()	Matches anything
expect(value).arrayContaining()	Array contains specific elements
expect(value).closeTo()	Number is approximately equal
expect(value).objectContaining()	Object contains specific properties
expect(value).stringContaining()	String contains a substring
expect(value).stringMatching()	String matches a regular expression


=========Soft assertions=========

page object models https://playwright.dev/docs/pom
https://prnt.sc/0rgQYfVVzDlM

drag and drop your test
https://trace.playwright.dev/


npx cucumber-js features/cmsPages.feature